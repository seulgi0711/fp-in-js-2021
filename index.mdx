import {
  Title,
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { github, vsDark, vsDark as imperativeTheme, nightOwl as fpTheme } from "@code-surfer/themes";
import roo from './roo.png'

export const theme = vsDark;

# Hello FP in JS 👋

<div>
비즈웹개발셀
</div>
<div>
theo.gt
</div>

<Notes>

안녕하세요. 반갑습니다. 비즈웹개발셀의 성슬깁니다.

오늘 제가 말씀드릴 주제는 함수형 프로그래밍에 대한 내용인데요. 함수형 프로그래밍을 자바스크립트라는 언어의 입장에서 접근하는 방식으로 설명 드리려고 합니다.

함수형 프로그래밍을 들으면 어떤 단어가 생각나시나요?

당연히 함수형 프로그래밍이니까 '함수'가 있을거구요. 그리고 '펑터', '모나드' 같은 단어들을 생각하시는 분들도 계시구요.

이런 단어들과 연관해서 '어렵다', '새로운 패러다임이다' 라고 생각하시는 분들도 계실겁니다.

그리고 완벽하게 반대라고 하기는 그렇지만 함수형 프로그래밍과 같이 자주 비교되는 'OOP'같은 단어들도 있습니다.

그래서 오늘 이런 여러가지 개념들을 최대한 이해하기 쉽게 풀어서 같이 한번 살펴보도록 하겠습니다.

</Notes>

---

# 살펴볼 내용

<ul>
  <li>Code Style</li>
  <li>Function Composition</li>
  <li>Pointfree Style & Currying</li>
  <li>Functional Programming Styles</li>
  <li>Functor & Error Handling</li>
</ul>

<Notes>

오늘 살펴볼 내용은 이런 내용들이 있습니다.

함수형 프로그래밍이 어떻게 생겼는지 살펴볼거구요.

그리고 함수 합성, 포인트프리 스타일과 커링.

함수형 프로그래밍의 스타일

펑터와 에러처리

</Notes>


---

# Code Style

코드 스타일

<Notes>

우선 코드 스타일인데요.

여기서는 함수형 프로그래밍이 어떻게 생겼는지 절차지향형 스타일의 코드와 함께 비교하면 살펴보도록 하겠습니다.

</Notes>

---

<CodeSurfer>

```json file=./src/CodeStyle/name-01.json title="Code Style" subtitle="FP 스터디 신청자 이름 목록"
```

</CodeSurfer>

<Notes>

자 여기 한가지 예제를 가지고 살펴볼게요.

FP 스터디에 참가할 사람들에게 신청을 받아서 각자의 이름을 받은 목록이 있다고 가정하겠습니다.

그런데 각자 입력을 해서 그런지 이름을 쓴 규칙이 다 달라서 통일성이 없습니다.

</Notes>

---

<CodeSurferColumns themes={[github, imperativeTheme]}>

<Step>

```markdown title="요구사항"
1. 성과 이름은 공백으로 구분
2. 성과 이름은 대문자로 시작
3. 오름차순 정렬
```

```json file=./src/CodeStyle/name-01.json title="변경 전"
```

</Step>

<Step>

```js 1 title="요구사항"
1. 성과 이름은 공백으로 구분
2. 성과 이름은 대문자로 시작
3. 오름차순 정렬
```

```json file=./src/CodeStyle/name-02.json title="변경 후"
```

</Step>

<Step>

```js 2 title="요구사항"
1. 성과 이름은 공백으로 구분
2. 성과 이름은 대문자로 시작
3. 오름차순 정렬
```

```json file=./src/CodeStyle/name-03.json title="변경 후"
```

</Step>

<Step>

```js 3 title="요구사항"
1. 성과 이름은 공백으로 구분
2. 성과 이름은 대문자로 시작
3. 오름차순 정렬
```

```json 2:11 file=./src/CodeStyle/name-com.json title="변경 후"
```

</Step>

</CodeSurferColumns>

<Notes>

그래서 이름 목록을 요구사항에 맞게 변경할 에정인데요.

첫 번째로 성과 이름은 공백으로 구분한다 입니다.

언더바와 대시 문자를 공백으로 맞춰주는 작업을 할 예정입니다. [enter]

그리고 두 번째로 성과 이름은 대문자로 시작한다.

(4번째 가리키며) 이런 형태로 바꿔줄 예정입니다. [enter]

마지막은 오름차순으로 정렬합니다. [enter]

</Notes>


---


<CodeSurferColumns sizes={[1, 2]} themes={[imperativeTheme, imperativeTheme]}>

<Step subtitle="Imperative: 이름 목록 순회">

```json file=./src/CodeStyle/name-01.json
```

```jsx file=./src/CodeStyle/imper-01.js
```

</Step>

<Step subtitle="공백으로 구분: 언더바(_), 대시(-) 문자를 빈 문자열로 대체">

```json file=./src/CodeStyle/name-02.json
```


```jsx file=./src/CodeStyle/imper-02.js
```

</Step>

<Step subtitle="대문자로 시작: 공백을 기준으로 이름을 쪼개준다.">

```json file=./src/CodeStyle/name-02.json
```


```jsx file=./src/CodeStyle/imper-03.js
```

</Step>

<Step subtitle="대문자로 시작: 쪼개준 이름의 첫 글자를 대문자로 바꿔준다.">

```json file=./src/CodeStyle/name-02.json
```



```jsx file=./src/CodeStyle/imper-04.js
```

</Step>

<Step subtitle="대문자로 시작: splitName을 공백을 넣어서 join 한다.">

```json file=./src/CodeStyle/name-03.json
```


```jsx file=./src/CodeStyle/imper-05.js
```

</Step>

<Step subtitle="오름차순 정렬: sort 메소드 이용">

```json file=./src/CodeStyle/name-com.json
```


```jsx file=./src/CodeStyle/imper-com.js
```

</Step>

<Step>

```json 1:21 file=./src/CodeStyle/name-com.json
```


```jsx 5:23 file=./src/CodeStyle/imper-com.js
```

</Step>

</CodeSurferColumns>

<Notes>

이 요구사항을 가지고 절차지향 코드부터 살펴보겠습니다.

이름이 리스트이기 때문에 for loop를 가지고 순회하면서 각 이름에 접근할 수 있습니다. [enter]

그리고 첫번째 요구사항인 '성과 이름은 공백으로 구분한다.'를 구현하기 위해 replace를 사용해서 언더바와 대시를 공백으로 바꿔준 후 원래 자리에 다시 저장해줍니다. [enter]

그리고 두 번째 요구사항인 성과 이름은 대문자로 시작한다를 구현하기 위해서 우선 성과 이름을 공백을 기준으로 나눠줍니다. 
그다움 splitName이라는 변수에 이름과 성이 쪼개진 배열이 저장합니다.[enter]

그리고 이렇게 쪼갠 splitName을 다시한번 for loop로 순회하면서 이름과 성에 대해서 첫번째 글자만 대문자로 바꿔줍니다. 그리고 splitName의 원래 자리에 다시 저장합니다. [Enter]

이제 성과 이름이 대문자로 변경된 splitName을 join으로 합쳐서 원래 이름에 저장해줍니다. [enter]

미지막으로 오름차순 정렬을 하기 위해 sort 메소드를 이용하면 원하는 요구사항을 모두 만족하게 됩니다.

</Notes>


---


<CodeSurferColumns sizes={[1, 2]}themes={[fpTheme, fpTheme]}>

<Step subtitle="Functional: map 메소드를 이용하면 순회하며 변경 가능">

```json file=./src/CodeStyle/name-01.json
```

```jsx file=./src/CodeStyle/fp-01.js
```

</Step>

<Step subtitle="공백으로 구분: replaceSpace라는 함수를 정의해서 map 함수로 넘겨준다.">

```json file=./src/CodeStyle/name-02.json
```


```jsx file=./src/CodeStyle/fp-02.js
```

</Step>

<Step subtitle="대문자로 시작: 우선 string의 첫 글자를 대문자로 바꿔주는 함수 정의">

```json file=./src/CodeStyle/name-02.json
```

```jsx file=./src/CodeStyle/fp-03.1.js
```

</Step>

<Step subtitle="대문자로 시작: 이름을 받아서 공백 기준으로 첫 글자만 대문자로 바꿔주는 함수를 정의">

```json file=./src/CodeStyle/name-02.json
```

```jsx file=./src/CodeStyle/fp-03.2.js
```

</Step>

<Step subtitle="대문자로 시작: map + changePartStartCase">

```json file=./src/CodeStyle/name-03.json
```

```jsx file=./src/CodeStyle/fp-03.3.js
```

</Step>

<Step subtitle="오름차순 정렬">

```json file=./src/CodeStyle/name-com.json
```


```jsx file=./src/CodeStyle/fp-com.js
```

</Step>

<Step>

```json file=./src/CodeStyle/name-com.json
```

```jsx 5:20 file=./src/CodeStyle/fp-com.js
```

</Step>

</CodeSurferColumns>

<Notes>

다음으로 함수형 프로그래밍 스타일을 살펴보겠습니다. Array에 있는 map 메소드를 사용하면 이름을 순회하면서 변경을 할 수 있습니다. [enter]

첫번째 요구사항인 '성과 이름은 공백으로 구분한다.'를 구현하기 위해 replaceSpace라는 함수를 하나 만들어 줍니다. 그리고 이 함수를 map 함수에서 사용하면 왼쪽과 같이 변경이 됩니다. [enter]

그리고 두 번째 요구사항인 '성과 이름은 대문자로 시작한다'를 구현하기 위해서 우선 스트링을 받아서 첫 글자만 대문자로 바꿔주는 함수를 하나 만듭니다. [enter]

그리고 이름을 받아서 성과 이름을 대문자로 바꿔주는 함수를 구현합니다. 먼저 공백으로 쪼개고 이렇게 쪼개진 이름과 성에 대해서 방금 만든 startCase 함수를 적용하면 각 문자열은 대문자로 시작하게 됩니다. 이 결과를 다시한번 join으로 합쳐서 반환합니다.[enter]

이렇게 만든 함수를 map 메소드를 이용해서 다시 한번 적용해주면 두 번째 요구사항을 구현하게 됩니다. [enter]

미지막으로 오름차순 정렬을 하기 위해 sort 메소드를 이용하면 원하는 요구사항을 모두 만족하게 됩니다.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step>

```jsx file=./src/CodeStyle/imper-com.js title="Imperative"
```

```jsx file=./src/CodeStyle/fp-com.js title="Functional"
```

</Step>

<Step>

```jsx 5,6,21 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="for loop로 순회"
```

```jsx 18[4:7,36],19[4:7,43] file=./src/CodeStyle/fp-com.js title="Functional" subtitle="map 메소드로 순회"
```

</Step>

<Step>

```jsx 6,7 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="성과 이름은 공백으로 구분: replace로 변경 후 spaceName에 저장"
```

```jsx 5:7,18 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="성과 이름은 공백으로 구분: map + replaceSpace"
```

</Step>

<Step>

```jsx 13:15 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="앞글자만 대문자로 변경 후 재 할당"
```

```jsx 9:11 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="앞글자만 대문자로 변경 후 반환"
```

</Step>

<Step>

```jsx 9:20 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="이름을 공백으로 쪼개서 for loop를 이용해 앞글자만 대문자로 변경후 재 할당"
```

```jsx 9[7:15],13:15,19 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="map + changePartStartCase: 앞에 정의한 startCase를 map과 함께 사용해서 반환"
```

</Step>

<Step>

```jsx 23 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="오름차순 정렬"
```

```jsx 20 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="오름차순 정렬"
```

</Step>

<Step subtitle="두가지 스타일의 코드에서 차이가 느껴지시나요?">

```jsx 5:23 file=./src/CodeStyle/imper-com.js title="Imperative"
```

```jsx 5:20 file=./src/CodeStyle/fp-com.js title="Functional"
```

</Step>

<Step>

```jsx 6[9:12],7[9:17],9[9:17],12[9:16],13[5:12],17[5:16],20[3:10] file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="값을 저장할 변수 선언과 재할당"
```

```jsx 17:20 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="값을 저장하는 변수 사용 안함"
```

</Step>

<Step>

```jsx 5,7,9,11,14,15,17,20 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="코드 표현: 어떻게(How)"
```

```jsx 17:20 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="코드 표현: 무엇(What)"
```

</Step>

<Step>

```jsx 5:23 file=./src/CodeStyle/imper-com.js title="Imperative" subtitle="함수 없음"
```

```jsx 5,9,13 file=./src/CodeStyle/fp-com.js title="Functional" subtitle="함수 기반"
```

</Step>

<Step>

```jsx 5:23 file=./src/CodeStyle/imper-com.js title="Imperative"
```

```jsx 5:22 file=./src/CodeStyle/fp-com.js title="Functional"
```

</Step>

</CodeSurferColumns>

<Notes>

이제 두가지 방식을 같이 보면서 요구사항을 어떻게 해결하는지 살펴보겠습니다. [enter]

우선 이름의 목록을 순회하기 위해서 각각 for loop와 map 메소드를 사용합니다. [enter]

그리고 첫번째 요구사항을 해결하기 위해서 절차지향 스타일은 Replace로 변경 후 spaceName이라는 변수에 저장을 하구요.
함수형 스타일은 replaceSpace라는 함수를 만들어서 map 메소드와 함께 사용합니다. [enter] 

두 번째 요구사항을 해결하기 위해서 앞글자를 대문자로 만들어 주는 부분인데요. 절차지향은 대문자 변경 후 다시한번 변수에 할당합니다.
함수형 스타일은 startCase라는 함수를 하나 정의합니다. [enter]

이제 요구사항 만족을 위해서 절차지향은 이름을 공백으로 쪼개고 for loop를 이용해 변경 후 재할당을 해줍니다.
함수형 스타일은 chagePartStartCase라는 함수를 만드는데 startCase와 함께 조합해서 구현합니다. [enter]

마지막으로 sort는 같은 형태로 구현합니다.
두가지의 차이점이 느껴지시나요?

(각 차이점 설명 후)
개인적으로는 함수형 스타일이 절차지향 스타일보다 가독성이 좋다고 느껴지는것 같습니다.

</Notes>

---

# 함수형 프로그래밍의 특징

<Notes>

다음은 함수형 프로그래밍의 특징에 대해서 살펴보겠습니다.

</Notes>

---

<CodeSurfer>

```js title="First Class Function" subtitle="함수 선언"
function startCase(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

startCase('hello'); // Hello
```

```js title="First Class Function" subtitle="함수를 변수에 할당하는 형태로 선언할 수 있다."
const startCase = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

const startCase = function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

startCase('hello'); // Hello
```

```js 1[64:90],2,3[1] title="First Class Function" subtitle="함수를 파라미터로 전달"
document.querySelector('.my-button').addEventListener('click', (event) => {
  console.log('버튼 클릭!');
})
```

```js 2:4 title="First Class Function" subtitle="함수를 리턴하는 함수"
const returnFunction = () => {
  return () => {
    // ...
  }
}
```

</CodeSurfer>

<Notes>

함수형 프로그래밍의 특징 중 하나는 일급 함수라는 점인데요. 함수를 변수와 같이 사용할 수 있다는 뜻입니다.

자바스크립트에서 함수를 선언할 때 이렇게 선언할 수 있습니다. [enter]

그런데 함수를 변수에 할당하는 형태로 선언할 수 있습니다. [enter]

그리고 또 변수처럼 사용할 수 있기 때문에 함수를 파라미터로 넘길 수 있습니다. [enter]

그리고 어떤 함수가 반환하는 값이 함수를 반환할수도 있습니다.

</Notes>

---

<CodeSurfer>

```js title="Pure Function" subtitle="파라미터에만 의존하는 순수 함수"
const negate = (num) => {
  return num * -1;
}
```

```js title="Pure Function" subtitle="외부 변수에 의존하는 불순 함수"
let num = 10;

const negate = () => {
  return num * -1;
}
```

```js title="Pure Function" subtitle="maxNum이 다른곳에서 바뀐다면?"
let maxNum = 5;

const isGraterThanFive = (num) => {
  return num > maxNum;
}

isGraterThanFive(10);
// true
```

```js title="Pure Function" subtitle="결과 값이 달라진다."
const isGraterThanFive = (num) => {
  return num > maxNum;
}

maxNum = 20;

isGraterThanFive(10);
// flase
```


```js title="Pure Function" subtitle="Immutable"
const replaceSpace = (str) => {
  return str.replace(/(_|-)/, ' ');
}

const startCase = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

const changePartStartCase = (str) => {
  return str.split(' ').map(startCase).join(' ')
}
```

```js title="Pure Function" subtitle="기존 값을 변경하지 않고, 새로운 값을 반환. 즉, 사이드 이펙트 없음."
const replaceSpace = (str) => {
  return str.replace(/(_|-)/, ' ');
}

const startCase = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

const changePartStartCase = (str) => {
  return str.split(' ').map(startCase).join(' ')
}

const name = 'leah kelly';
const startCaseName = changePartStartCase(str);

console.log(name); // 'leah kelly'
console.log(startCaseName); // 'Leah Kelly'
```

</CodeSurfer>

<Notes>

함수형 프로그래밍의 두 번째 특징은 순수함수를 사용해야 한다는 점입니다.

여기 negate라는 함수가 있는데요. 이 함수는 파라미터로 받는 num이라는 값에만 의존하고 있습니다. 이런 함수를 순순함수 라고 합니다. [enter]

그에 반해, 이 negate 함수는 함수 밖에 있는 변수 값에 의존하고 있습니다. 이런 함수를 불순 함수라고 부릅니다. 이런 경우 num 값이 다른곳에서 바뀌게 되면 함수의 결과가 매번 달리지게 되겠죠. [enter]

여기 isGraterThanFive 이라는 함수가 있습니다. 파라미터로 넘긴 숫자 값이 maxNum인 5보다 큰지 확인하는 함수인데요. 지금 이렇게 10을 넘기면 5보다 크기 때문에 ture가 됩니다. 그런데 maxNum이 어딘가에서 바뀐다면 어떻게 될까요? [enter]

이렇게 20으로 바뀌게 되면 같은 숫자인 10을 넘겨도 결과는 달라지게 됩니다. 이런 부분들이 의도치 않은 사이드이펙트를 발생시키게 됩니다. [enter]

순수함수는 이렇게 외부 값에 의존하지 않고 외부 값을 바꾸지도 않습니다.
이런 특성을 Immutable이라고 합니다.
여기 있는 세가지 함수는 모두 str이라는 변수를 받지만 str 변수 자체의 값을 변경하지 않고 새로운 문자열을 만들어서 반환하게 됩니다. [enter]

그래서 name을 changePartStartCase라는 함수에 넘긴 후 name과 함수 결과값을 로그로 찍어보면 기존 name은 그대로 있고 새로운 문자열이 반환된것을 볼 수 있습니다.

</Notes>

---

# Function Composition

함수 합성

<Notes>

다음은 함수합성에 대한 얘기를 해볼까 합니다.

말 그대로 여러 작은 함수를 합성해서 데이터를 변경하는 작업을 의미합니다.

</Notes>

---

<CodeSurfer>

```js file=./src/FunctionComposition/1-1.js subtitle="아무 생각없이 만든 함수"
```

```js file=./src/FunctionComposition/1-2.js subtitle="2의 네 제곱"
```

```js file=./src/FunctionComposition/1-3.js subtitle="음수 변환"
```

```js file=./src/FunctionComposition/1-4.js subtitle="더하기 1"
```

```js 16[7:13],17[7:13],18[7:13] file=./src/FunctionComposition/1-4.js subtitle="변수를 한번 사용하기 때문에 크게 의미가 없다."
```

```js file=./src/FunctionComposition/1-5.js subtitle="불필요 변수 제거"
```

```js file=./src/FunctionComposition/1-com.js subtitle="읽기 힘들다..."
```

</CodeSurfer>

<Notes>

여기 그냥 몇가지 함수를 정의했습니다. [enter]

2의 네 제곱을 해서 powered라는 변수에 저장합니다. [enter]

그리고 이 결과를 음수로 바꿔서 negated에 저장해줍니다. [enter]

다시 한번 그 결과에 더하기 1을 해서 result라는 변수에 저장합니다. [enter]

그런데 각 단계별로 저장하는 변수들은 다음 단계에서 딱 한번 사용되기 때문에 크게 의미가 없습니다. [enter]

그래서 불필요한 변수를 제고하고 함수의 결과를 그 다음 함수의 파라미터로 넘긴 형태러 작성하면 이렇게 됩니다.
이런 형태는 가장 안쪽부터 바깥쪽으로 코드를 읽어 나가야 합니다.
익숙한 형태는 아닙니다. [enter]

그런데 이런 형태로 적용해야 하는 함수가 더 많아진다고 하면 어떨까요? 읽기가 더욱 힘들어지겠죠?
그리고 이런 형태는 우리 모두가 어렸을적 수학시간에 배웠던 수학적인 함수 합성 표현법과 비슷하다는 느낌도 듭니다. [enter]

</Notes>


---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step subtitle="함수 합성의 수학적 표현">

```js
(h ・ g ・ f)(x) = h( g( f( x ) ) )
```

```js
inc(negate(pow(2, 4)));
```

</Step>

</CodeSurferColumns>

<Notes>

그래서 더 거부감이 드는것 같아요.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step subtitle="수학적 표현을 읽기 편하게 바꿔줄 compose 함수">

```js file=./src/FunctionComposition/compose.js
```

```js file=./src/FunctionComposition/1-5.js
```

</Step>

<Step subtitle="fns: 실행할 함수 목록">

```js 1[18:23] file=./src/FunctionComposition/compose.js
```

```js 17:19 file=./src/FunctionComposition/compose-1.js
```

</Step>

<Step subtitle="함수 목록을 넘겨주면 함수를 조합한 새로운 함수를 반환한다.">

```js 2:7 file=./src/FunctionComposition/compose.js
```

```js file=./src/FunctionComposition/compose-2.js
```

</Step>

<Step subtitle="반환한 함수는 함수 조합의 파라미터로 넘겨줄 값을 인자로 받는다.">

```js 2[11:17] file=./src/FunctionComposition/compose.js
```

```js 22[16:19] file=./src/FunctionComposition/compose-3.js
```

</Step>

<Step subtitle="compose에 넘겨줬던 함수 목록을 reduceRight로 오른쪽 함수부터 실행한 결과를 다음 함수로 넘겨서 실행한다.">

```js 3:6 file=./src/FunctionComposition/compose.js
```

```js file=./src/FunctionComposition/compose-4.js
```

</Step>

<Step subtitle="">

```js 3:6 file=./src/FunctionComposition/compose.js
```

```js file=./src/FunctionComposition/compose-5.js
```

</Step>

<Step subtitle="">

```js 3:6 file=./src/FunctionComposition/compose.js
```

```js file=./src/FunctionComposition/compose-6.js
```

</Step>

<Step>

```js subtitle="그냥 합성"
inc(negate(pow(2, 4)));
```

```js subtitle="compose 합성"
compose(
  (num) => inc(num),
  (num) => negate(num),
  (num1, num2) => pow(num1, num2)
)
```

</Step>

</CodeSurferColumns>

<Notes>

이런 거부감이 드는 수학적 표현 코드 스타일을 읽기 편하게 바꿔줄 수 있는 함수를 하나 만들어 사용합니다.

이 함수의 이름은 compose 인데요. [enter]

compose 함수는 파라미터로 실행할 함수 목록을 받습니다. [enter]

그리고 반환하는 값은 새로운 함수를 반환해줍니다. 그래서 오른쪽과 같이 변수에 저장을 할수 있습니다. [enter]

이렇게 반환된 함수는 파라미터를 받는데요. 이 파라미터는 처음에 넘겨줬던 실행할 함수 목록중 첫번째로 실행될 함수의 파라미터로 들어갈 값입니다. 오른쪽과 같이 저장했던 함수를 실행하면 [enter]

이제 각 함수의 목록을 reduceRight라는 메소로 순회를 하면서 실행합니다. 이때 reduceRight를 사용하기 때문에 가장 마지막에 넘겨줬던 함수부터 역순으로 실행해줍니다.
그래서 오른쪽의 마지막 함수의 파라미터에 각 2와 4가 들어가면서 2의 네제곱인 16이 반환됩니다. [enter]

그러면 16은 그 다음 함수의 파라미터로 들어가서 negate를 통해 -16으로 변경됩니다. [enter]

그리고 마지막 함수에 -16이 들어가면 inc 함수를 통해 +1을 해서 -15가 되고 함수는 종료하게 됩니다. [enter]

그런데 compose 합성을 한 방식이 더 복잡한 느낌이 드는것 같습니다. 그 이유와 개선 방법을 다음장에서 같이 살펴보도록 하겠습니다.

</Notes>

---

# Pointfree Style

포인트프리 스타일

<Notes>

이번 장은 포인트프리 스타일입니다. 방금전 살펴봤던 복잡해 보이는 문제를 해결할 방법을 같이 살펴보겠습니다.

</Notes>

---


<CodeSurfer>

```js file=./src/FunctionComposition/point-free-1.js
```

```js 2[3:11],3[3:11],4[3:18] file=./src/FunctionComposition/point-free-1.js subtitle="거슬리는 부분들"
```

```js 2[12:19] file=./src/FunctionComposition/point-free-1.js subtitle="inc 함수"
```

```js 2 file=./src/FunctionComposition/point-free-1.js subtitle="inc를 감싼 익명 함수"
```

```js 2 file=./src/FunctionComposition/point-free-1.js subtitle="inc와 (num) => inc(num) 은 같다"
```

```js file=./src/FunctionComposition/point-free-2.js subtitle="inc 그대로 사용 가능"
```

```js file=./src/FunctionComposition/point-free-3.js subtitle="나머지 함수도 바꿔준다."
```

```js file=./src/FunctionComposition/point-free-com.js"
```

</CodeSurfer>

<Notes>

지 여기 compose 형태의 합성입니다. [enter]

그런데 여기보면 저는 조금 거슬리는 부분이 있는것 같습니다. 왜그런가 하면 [enter]

`inc`라는 함수는 숫자를 하나 받는 함수입니다. [enter]

그리고 `inc`를 감싼 익명 함수는 숫자를 하나 받아서 `inc`함수를 그대로 실행해주는 함수입니다. [enter]

그럼 사실 `inc`를 감싼 익명함수 대신 `inc`함수를 그대로 사용하면 같은 동작을 합니다. [enter]

그럼 나머지 함수들도 보시면 구성하는 파라미터와 실행하는 각 함수의 파라미터 수가 동일하죠. 그럼 inc와 같은 형태로 바꿀 수 있습니다. [enter]

그래서 아까 구현했던 코드를 이렇게 바꿀 수 있습니다.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step subtitle="Pointfree Style">

```js
compose(
  (num) => inc(num),
  (num) => negate(num),
  (num1, num2) => pow(num1, num2)
)(2, 4); // -15
```

```js
compose(
  inc,
  negate,
  pow
)(2, 4); // -15
```

</Step>

</CodeSurferColumns>

<Notes>

그리고 이런 스타일의 코드를 이번장의 주제인 포인트 프리 스타일이라고 부릅니다.

포인트 프리 스타일은 왼쪽 코드와 비교해보면 파라미터 정보를 표현하지 않는 형태입니다.

이런 형태의 코드 스타일을 사용하면 불필요한 파라미터 정보를 제거할 수 있어서 복잡해 보일 수 있는 코드를 간단하게 만들 수 있습니다.

</Notes>

---

<CodeSurfer>

```js subtitle="compose 함수는 오른쪽 -> 왼쪽으로 흐르는 함수 합성한다. 뭔가 불편..."
compose( inc, negate, pow )(2, 4); // -15
```

```js file=./src/FunctionComposition/pipe-1.js subtitle="compose 구현 왼쪽 -> 오른쪽으로 실행하고 싶다."
```

```js file=./src/FunctionComposition/pipe-2.js subtitle="reduceRight를 reduce로 바꿔만 주면 된다."
```

```js file=./src/FunctionComposition/pipe.js subtitle="그리고 함수 이름을 pipe로 바꿔주자."
```

</CodeSurfer>

<Notes>

자 그런데, 지금 우리가 사용하는 compose 함수는 함수 실행을 오른쪽에서 왼쪽으로, 즉 역순으로 실행합니다.

사람에 따라 다르겠지만 저는 뭔가 좀 불편한 느낌이 드는것 같습니다. [enter]

그래서 이 순서를 왼쪽에서 오른쪽으로 실행하도록 바꾸고 싶은데요. 그러려면 여기 reduceRight를 reduce로만 바꿔주면 됩니다. [enter]

그리고 함수명을 pipe로 바꿔줍니다.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step>

```js subtitle="compose"
compose(inc, negate, pow);
```

```js subtitle="pipe"
pipe(pow, negate, inc);
```

</Step>

</CodeSurferColumns>

<Notes>

이렇게 하면 기존 compose 방식은 오른쪽에서 왼쪽으로 실행하는 반면, pipe 함수는 왼쪽에서 오른쪽으로 뭔가 좀더 자연스러운 방향으로 실행할 수 있게 됩니다.

이 이후로 나오는 예제에서는 모두 pipe를 사용해서 함수 합성을 진행하도록 하겠습니다.

</Notes>

---

# Currying

커링

<Notes>

다음으로 커링에 대해서 살펴볼 건데요.

우선 예제를 가지고 먼저 살펴보겠습니다. 

</Notes>

---

<CodeSurferColumns themes={[github, imperativeTheme]}>

<Step>

```markdown title="요구사항"
1. age 프로퍼티를 지운다.
2. work 프로퍼티 명을 job으로 바꾼다.
```

```jsx title="변경 전"
const person = {
  name: 'theo.gt',
  age: 15,
  work: 'developer'
};
```

</Step>

<Step>

```markdown 1 title="요구사항"
1. age 프로퍼티를 지운다.
2. work 프로퍼티 명을 job으로 바꾼다.
```

```jsx title="변경 후"
const person = {
  name: 'theo.gt',
  work: 'developer'
};
```

</Step>

<Step>

```markdown 2 title="요구사항"
1. age 프로퍼티를 지운다.
2. work 프로퍼티 명을 job으로 바꾼다.
```

```jsx title="변경 후"
const person = {
  name: 'theo.gt',
  job: 'developer'
};
```

</Step>

</CodeSurferColumns>

<Notes>

여기 Person 객체가 하나 있는데요. 요구사항이 두 가지가 있습니다.

첫 번째로 age가 거짓말이기 때문에 age 프로퍼티를 지워줍니다. [enter]

두 번째로 work라는 프로퍼티명을 job으로 바꿔줍니다. [enter]

</Notes>

---

<CodeSurfer>

```js file=./src/Currying/without-cyrring-1.js subtitle="dissoc과 rename 함수를 정의"
```

```js file=./src/Currying/without-cyrring-2.js subtitle="pipe를 이용해서 구현"
```

```js 17,18 file=./src/Currying/without-cyrring-2.js subtitle="파라미터가 2개여서 Pointfree Style을 사용할수 없다. 지저분해진다."
```

```js 17,18 file=./src/Currying/without-cyrring-2.js subtitle="파라미터를 하나로 만들수만 있다면 Pointfree Style을 사용할 수 있다."
```

</CodeSurfer>

<Notes>

요구사항 구현을 위해서 property를 삭제하는 함수인 dissoc 함수를 정의하구요. property 명을 변경하는 rename이라는 함수를 정의합니다.

이 두가지 함수는 각 각 필요한 파라미터 두개를 받습니다. 여기서 세부 구현은 중요하지 않기 때문에 생략하도록 하겠습니다. [enter]

이제 pipe 함수를 이용해서 구현을 한 코드입니다.
첫번째로 dissoc을 가지고 age를 지워주구요.
두 번째로 rename을 이용해서 work를 job으로 바꾸도록 처리하고 있습니다. [enter]

그런데 여기서 아까 봤던 파라미터를 생략한 포인트프리 스타일이 불가능합니다.
왜냐하면 익명함수에 받는 파라미터 수와 dissoc과 rename이 받는 파라미터 수가 다르기 때문입니다.
뭔가 저는 좀 지저분해보이는것 같습니다. [enter]

dissoc과 rename의 파라미터를 하나로 만들수만 있다면 Pointfree Style을 사용할 수 있을것 같습니다.

여기서 등장하는 것이 바로 커링입니다. [enter]


</Notes>

---

# Currying

> 파라미터를 모두 채우지 않는 한 함수로 남아있겠다.

<Notes>

이 커링을 한마디로 표현하자면 여기 나와있는 '파라미터를 모두 채우지 않는 한 함수로 남아이겠다.' 로 표현할 수 있습니다.

이게 무슨뜻인지 한번 살펴보도록 하겠습니다.

</Notes>

---

<CodeSurfer>

```js file=./src/Currying/with-currying-1.js subtitle="dissoc은 파라미터 두개를 받는다."
```

```js file=./src/Currying/with-currying-2.js subtitle="첫 번째 파라미터를 미리 받고 나머지 파라미터를 나중에 받아서 실행할 수 있다면 좋겠다."
```

```js file=./src/Currying/with-currying-3.js subtitle="파라미터 하나를 받아서 두 번째 파라미터를 받는 새로운 함수를 반환해주자."
```

```js file=./src/Currying/with-currying-4.js subtitle="rename도 같은 방식으로 바꿔주자."
```

```js 1:17 file=./src/Currying/with-currying-5.js subtitle="처음으로 돌아가자"
```

```js file=./src/Currying/with-currying-6.js subtitle="dissoc에 지워주고 싶은 age를 미리 넣어주면 person만 받을 수 있는 함수가 된다."
```

```js file=./src/Currying/with-currying-7.js subtitle="깔끔하게 dissoc을 사용할 수 있다."
```

```js file=./src/Currying/with-currying-8.js subtitle="rename도 바꿔주고 싶은 property명을 미리 넘겨주자. Pointfree Style로 깔끔해졌다."
```

```js 1,2,7,8 file=./src/Currying/with-currying-8.js subtitle="Currying: 파라미터를 모두 채우지 않는 한 함수로 남아있겠다."
```

</CodeSurfer>

<Notes>

여기보시면 dissoc은 파라미터를 두개 받습니다. [enter]

그런데 이런 형태를 첫번째 파라미터인 'age'를 미리 받고 나머지 파라미터를 이후에 받아서 실행할 수만 있으면 이 코드와 같이 하나의 파라미터를 받는 함수로 만들 수 있습니다.
그러면 포인트프리 스타일로 사용할 수 있을것 같은데요. [enter]

이걸 구현하기 위해서 dissoc의 구현을 조금 바꿔줩니다. 먼저 파라미터를 하나만 받는 함수로 바꿔주구요. 이 반환값은 나머지 파라미터를 받는 함수를 반환해줍니다. 세부 구현은 이전과 같겠죠. [enter]
rename도 같은 방식으로 바꿔줍니다. [enter]

[etner] (한번 더)

그리고 dissoc에 age를 먼저 넣어주면 person만 받는 새로운 함수가 반환됩니다. [enter]
그러면 이렇게 깔끔하게 사용할 수 있습니다. [enter] rename도 같은 방식으로 사용하면 우리가 원했던 포인트 프리 스타일로 사용할 수 있습니다. [enter]

여기서 본것 처럼 두개의 파라미터를 받는 함수에서 하나만 채워서 나머지 파라미터를 받는 함수를 반환하기 때문에

'파라미터를 모두 채우지 않는한 함수로 남아있겠다'는 표현이 되는 겁니다.

그런데 모든 함수를 이렇게 수동으로 커링하기는 너무 힘들기 때문에 함수를 자동으로 커링해줄 헬퍼함수를 하나 만들어 줍니다.


</Notes>

---

<CodeSurfer>

```js file=./src/Currying/currying.js
```

```js 5:7 file=./src/Currying/currying.js subtitle="파라미터 수가 부족하면 일부만 바인딩"
```

```js 9 file=./src/Currying/currying.js subtitle="파라미터 수가 맞으면 실행"
```

```js 1:7 file=./src/Currying/with-curry-func.js
```

</CodeSurfer>

<Notes>

자 여기 curry라는 이름의 함수를 하나 정의 하는데요. 세부 구현은 나중에 보시면 충분히 이해가 되실테니 중요한곳만 좀 살펴보겠습니다. [enter]

여기 함수의 파라미터수가 부족하면 일부만 바인딩해서 다시 한번 반환을 해주구요. [enter]

그렇지 않고 파라미터 수가 맞아 떨어지면 그대로 실행하도록 구현한 부분입니다. [enter]

그래서 이렇게 dissoc과 rename을 curry 함수로 감싸서 커링된 함수로 만들어줄 수 있습니다.

</Notes>

---

# 함수형 스타일 비교

메소드 체이닝 vs 파이프라이닝

<Notes>

다음으로 함수형 프로그래밍 스타일에는 메소드 체이닝과 파이프라이닝이 있는데요.

지금까지 pipe나 compose를 사용한 방식이 파이프라이닝 방식입니다. 그리고 메소드 체이닝 방식은 맨 처음 살펴봤던 예제에서 나왔는데요.

이 두가지 스타일을 한번 비교해 보도록 하겠습니다.

간단하고 자주 쓰이는 함수를 제공하는 라이브러리가 있는데요. 대표적으로 많이 사용하는 lodash와, 함수형 프로그래밍에 최적화 된 ramdajs를 가지로 비교해보도록 하겠습니다.

두 가지 모두 간단하면서도 유용한 함수들을 제공하는데요. 대표적인 예로 아까 예제에서 봤던 replace, startCase, join, split 등등 많은 기능을 제공합니다.

이 두가지 라이브러리를 이용해서 어떤 차이가 있는지 살펴보겠습니다.

</Notes>

---

<CodeSurfer>

```jsx file=./src/CodeStyle/chaining-ex.js title="메소드 체이닝"
```

```jsx file=./src/CodeStyle/chaining-ex-2.js title="메소드 체이닝" subtitle="LodashWrapper"
```

</CodeSurfer>

<Notes>

메소드 체이닝은 lodash를 가지고 설명하겠습니다.

lodash의 chain이라는 함수를 이용해서 메소드 체이닝을 시작합니다.

이후 점(.)을 이용해 지속적으로 체이닝을 이어 나가며 데이터를 처리해 나가는데요.

마지막에 value를 호출해서 최종적으로 값을 추출해 냅니다.

_.chain에 names을 파라미터로 호출 하면 LodashWrapper 라는 객체가 반환됩니다. [enter]

이 LodashWrapper에서 제공하는 map, sort, value와 같은 메소드를 사용해서 체이닝을 이어 나가게 됩니다.

</Notes>

---

<CodeSurfer>

```jsx file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝"
```

```jsx 3:5,9 file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝"
```

</CodeSurfer>

<Notes>

파이프라이닝은 ramdajs 라이브러리를 사용했습니다.

pipe 라는 함수에 처리할 로직 함수들을 전달하고 마지막으로 names를 전달해서 처리합니다.

파이프라이닝도 마찬가지로 위에서부터 아래로 처리 결과를 흘려보내주면서 최종적으로 결과를 반환합니다. [enter]

ramdajs에서는 startCase 함수를 제공하지 않아 직접 구현해서 사용했습니다.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step>

```jsx file=./src/CodeStyle/chaining-ex.js title="메소드 체이닝"
```

```jsx file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝"
```

</Step>

<Step>

```jsx 4[3:6],5[3:6],6[3:7],7[3:8] file=./src/CodeStyle/chaining-ex.js title="메소드 체이닝"
```

```jsx 8[3:7],9[3:7],10[3:10] file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝"
```

</Step>

<Step>

```jsx file=./src/CodeStyle/chaining-ex.js title="메소드 체이닝" subtitle="단단한 결합"
```

```jsx file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝" subtitle="느슨한 결합"
```

</Step>

<Step>

```jsx file=./src/CodeStyle/chaining-ex.js title="메소드 체이닝" subtitle="제한된 표현성"
```

```jsx file=./src/CodeStyle/pipelining-ex.js title="파이프라이닝" subtitle="유연함"
```

</Step>

</CodeSurferColumns>

<Notes>

두가지 방법에 대한 차이점을 살펴볼까요? [enter]

메소드 체이닝은 점(.)을 이용해서 LodashWrapper가 제공하는 메소드를 사용해서 데이터를 처리해 나갑니다.
반면, 메소드 파이프라인은 pipe 라는 함수에 원하는 함수를 차례대로 인자로 넘겨서 데이터를 처리해 나갑니다. [enter]

여기서 차이를 느끼셨나요? 메소드 체이닝은 LodashWrapper 객체를 이용하기 때문에 여기서 제공하는 메소드만을 사용할 수 있습니다.

즉, 단단한 결합으로 돼있다고 볼 수 있을것 같습니다.

파이프라이닝은 원하는 함수를 만들어서 중간에 끼워 넣을 수 있습니다.

즉, 느슨한 결합으로 돼있다고 보면 될 것 같습니다. [enter]

한 마디로 제한된 표현성과 유연함의 차이라고 생각하시면 됩니다.

이부분에 있어서 좀 더 이해하기 쉬운 상황을 예로 들어보겠습니다.

</Notes>

---

<CodeSurferColumns themes={[github, imperativeTheme]}>

<Step>

```markdown title="요구사항"
1. age 프로퍼티를 지운다.
2. work 프로퍼티 명을 job으로 바꾼다.
```

```jsx title="변경 대상"
const person = {
  name: 'theo.gt',
  age: 15,
  work: 'developer'
};
```

</Step>

</CodeSurferColumns>

<Notes>

아까전의 예제로 다시 살펴보겠습니다.

</Notes>

---

<CodeSurferColumns themes={[imperativeTheme, fpTheme]}>

<Step>

```jsx file=./src/CodeStyle/chaining-1.js title="메소드 체이닝" subtitle="Lodash Wrapper로 만들어준다"
```

```jsx file=./src/CodeStyle/pipelining-1.js title="파이프라이닝" subtitle="pipe의 시작 파라미터로 만들어준다"
```

</Step>

<Step subtitle="lodash와 ramda의 omit으로 age를 지운다">

```jsx file=./src/CodeStyle/chaining-2.js title="메소드 체이닝"
```

```jsx file=./src/CodeStyle/pipelining-2.js title="파이프라이닝"
```

</Step>


<Step>

```jsx file=./src/CodeStyle/chaining-3.js title="메소드 체이닝" subtitle="rename 함수를 끼워 넣을 수 없다."
```

```jsx file=./src/CodeStyle/pipelining-com.js title="파이프라이닝" subtitle="rename 함수를 정의해서 끼워준다."
```

</Step>

<Step>

```jsx file=./src/CodeStyle/chaining-com.js  subtitle="age까지만 제거하고 계산한 후 마지막에 rename을 다시 적용한다."
```

```jsx file=./src/CodeStyle/pipelining-com.js
```

</Step>

<Step subtitle="메소드 체이닝은 제공되지 않는 메소드 외에는 이어서 붙일 수 없다.">

```jsx file=./src/CodeStyle/chaining-com.js
```

```jsx file=./src/CodeStyle/pipelining-com.js
```

</Step>

<Step>

```jsx file=./src/CodeStyle/chaining-com.js subtitle="단단한 결합"
```

```jsx file=./src/CodeStyle/pipelining-com.js subtitle="느슨한 결합"
```

</Step>

</CodeSurferColumns>

<Notes>

각각의 방법을 같이 보게 되면. 메소드 체이닝은 LodashWrapper로 만들어 주는 chain 함수로 시작을 합니다.
그리고 파이프라이닝 방식은 pipe 함수를 사용하게 됩니다. [enter]

age 라는 프로퍼티를 지우기 위해서 LodashWrapper에 있는 omit과 ramd의 omit을 사용합니다. 

work라는 프로퍼티를 job으로 바꿔줘야 하는데요. [enter]

LodashWrapper에는 프로피터 명을 바꿔주는 메소드를 제공하지 않습니다. 그래서 당장은 바꿀수 있는 방법이 없습니다.
ramda 또한 마찬가지로 프로퍼티 명을 바꿔주는 함수를 제공하지 않습니다.

하지만 파이프라이닝은 그냥 함수를 중간에 끼워 넣기만 하면 되기 때문에 rename이라는 함수를 직접 만들어서 중간에 넣기만 하면 됩니다.  [enter]

결국 메소드 체이닝 방식은 age를 삭제한 결과를 중간에 저장하고, 마지막헤 rename 함수를 이용해 다시한번 요구사항을 만족시켜야 합니다. [enter]

이제 아까 말씀더렸던 단단한 결합과 유연함의 차이를 느끼셨을거라 생각이 듭니다.

결국 두가지 방식의 차이는 유연성의 차이 입니다.
그래서 파이프라이닝이 어떤 로직을 구현하는데 있어서 조금더 유연하게 구현할수 있다 라는게 더 큰 장점으로 올 수 있습니다.

</Notes>

---

# Functor

펑터

<Notes>

자 이제 함수형 프로그래밍에서 펑터라는 개념을 살펴볼 예정입니다.

펑터는 펑션과 이름이 비슷해서 함수와 같은건가라고 생갹하실 수 있는데요.

함수가 아니라 어떤 특정 조건을 만족하는 객체라고 생각하시면 될것 같습니다.

펑터가 뭔지 그리고 왜 펑터를 써야 하는지 같이 살펴보도록 하겠습니다.

</Notes>

---

<CodeSurfer>

```js file=./src/Functor/box-1.js subtitle="상자를 하나 만듭니다."
```

```js file=./src/Functor/box-2.js subtitle="값 저장"
```

```js file=./src/Functor/box-3.js subtitle="Box 인스턴스"
```

</CodeSurfer>

<Notes>

먼저 상자를 하나 만들어 보도록 하겠습니다.

이 상자 안에 값을 저장할수 있게 조금 바꿔보겠습니다. [enter]

자, 이렇게 컨스트럭터를 이용해서 값을 받도록 처리하고, 여기서 받은 값을 $value라는 필드에 할당하고 있습니다.

그리고 of 라는 스태틱 메소드를 만들어서 Box 인스턴스를 쉽게 만들수 있도록 처리합니다. [enter]

new 키워드를 이용해서 박스 인스턴스를 만들수 있구요. 또는 of 메소드를 사용해서 박스를 만들 수도 있습니다.

box3같은 경우는 먼저 Box.of('FP3')로 박스를 만들고 다시 한번 Box.of를 사용해서 상자 안에 상자를 넣은 상황 입니다.

</Notes>

---

<CodeSurferColumns themes={[github, imperativeTheme]}>

<Step>

```markdown title="요구사항"
1. id를 이용해서 책 찾기.
2. 찾은 책의 제목 첫글자를 대문자로 변경하기.
```

```json title="책 목록"
[
  { 
    "id": "book1", 
    "title": "coding with javascript" 
    },
  { 
    "id": "book2", 
    "title": "speaking javaScript"
  },
];
```

</Step>


</CodeSurferColumns>

<Notes>

자 그럼 이 박스를 사용해서 하나의 에제를 살펴보겠습니다.

오른쪽에 책 목록이 있는데요. 여기서 id를 가지고 책을 먼저 찾아줍니다.

그리고 찾은 책 제목의 첫글자를 대문자로 변경하는 작업을 하고 싶습니다.

</Notes>

---


<CodeSurfer>

```js file=./src/Functor/box-4.js
```

```js file=./src/Functor/box-5.js subtitle="첫 글자 대문자 변환"
```

```js file=./src/Functor/box-6.js subtitle="property 값 반환"
```

```js file=./src/Functor/box-7.js subtitle="id와 책 목록을 받아서 id에 해당하는 책 반환"
```

```js file=./src/Functor/box-8.js subtitle="원하는 결과를 만들 함수 정의"
```

```js file=./src/Functor/box-9.js subtitle="박스에 책 목록을 넣어줍니다."
```

```js file=./src/Functor/box-10.js subtitle="박스에 저장된 책 목록을 가지고 책을 찾아줍니다."
```

```js file=./src/Functor/box-11.js subtitle="찾은 책에서 title 값을 가져옵니다."
```

```js file=./src/Functor/box-12.1.js subtitle="앞글자만 대문자로 바꿔줍니다."
```

</CodeSurfer>

<Notes>

자, 우선 책 제목의 첫 글자를 대문자로 바꿔줘야 하기 때문에 startCase라는 함수를 만들어 줍니다. [enter]

그리고 찾은 책에서 title 값을 가져오기 위해 prop 함수를 만들어 줍니다. [enter]
객체에서 특정 프로퍼티 이름에 해당하는 값을 반환해주는 함수입니다. [enter]

그리고 책 아이디와 책 목록을 받아서 책을 찾아주는 findBookById를 만들어 줍니다.[enter]

그럼 이제 최종 결과를 만들어줄 함수를 작성해보도록 하겠습니다. 이 함수는 id와 책을 파라미터로 받아서 처리 합니다. [enter]

pipe함수를 가지고 박스 안에 books를 넣어 줍니다. [enter]

다음으로 우리가 만들었던 책을 찾는 함수인 getBookById를 사용하는데요. 책 목록이 박스 안에 들어있기 때문에 box.$value를 사용해서 책을 찾아 줍니다. [enter]

그리고 prop 함수에 title을 넘겨서 찾은 책의 제목을 반환하도록 합니다. [enter]

마지막으로 startCase를 사용해서 첫 글자만 대문자로 바꿔주도록 합니다.

</Notes>

---

<CodeSurfer>

```js 33 file=./src/Functor/box-12.1.js subtitle="앞글자만 대문자로 바꿔줍니다."
```

```js 31 file=./src/Functor/box-12.1.js subtitle="box.\$value"
```

```js 1:9 file=./src/Functor/box-12.1.js subtitle="상자에 특별한 기능을 넣어봅시다."
```

```js file=./src/Functor/box-13.js subtitle="map 메소드 추가"
```

```js 10[7:8] file=./src/Functor/box-13.js subtitle="파라미터로 함수"
```

```js 11[20:34] file=./src/Functor/box-13.js subtitle="받은 함수를 박스 안의 값에 적용"
```

```js 11 file=./src/Functor/box-13.js subtitle="함수 결과 값을 다시 한번 박스에 넣고 반환"
```

```js file=./src/Functor/map-1.1.js subtitle=""
```

```js file=./src/Functor/map-1.2.js subtitle=""
```

```js file=./src/Functor/map-1.3.js subtitle=""
```

```js file=./src/Functor/map-1.4.js subtitle=""
```

</CodeSurfer>

<Notes>

근데 뭔가 좀 이상하지 않나요? [enter]

상자에 값을 넣고 다시 빼서 쓸거면 뭐하러 상자에 넣을까요?
저렇게 상자에 넣고 다시 꺼내서 쓸거면 애초에 넣을 필요가 없을것 같습니다.

그래도 적어도 상자에 값을 넣은 행동에 의미가 있게 상자 안에 값을 유지한 상태로 바꿔보도록 하죠. [enter]

그러려면 상자에 특별한 기능을 붙여줘야 하는데요. [enter] map 이라는 메소드를 하나 추가 하도록 하겠습니다. [enter]

map 메소드는 파라미터로 함수를 하나 받습니다. [enter] 그리고 이 함수를 박스 안에 있는 값에 적용을 해주죠. [enter]

그리고 그 결과를 다시 한번 박스에 넣어서 반환을 해줍니다. [enter]

자 이렇게 새로 넣은 기능을 어떻게 사용하는지 살펴보기 위해서 addFive라는 함수를 하나 만들었습니다.
이 함수는 숫자를 받아서 단순히 5를 더해서 반환해주는 함수입니다. [enter]

그리고 Box에 1을 넣어 줍니다. [enter]

여기에 방금 만든 map 메소드를 이용해서 addFive를 넣어주면 상자 안에 있던 1값에 5를 더한 6을 상자에 넣어서 다시 반환해 줍니다. [enter]

여기다가 다시 한번 같은 동작을 해주면 박스 안에 있는 6에 5를 더해서 11을 담은 박스를 다시 반환해 줍니다. [enter]


</Notes>

---

<CodeSurfer>

```js 23,26 file=./src/Functor/map-1.4.js subtitle=""
```

```js file=./src/Functor/map-2.1.js subtitle=""
```

```js file=./src/Functor/map-2.2.js subtitle=""
```

</CodeSurfer>

<Notes>

하나만 더 볼까요?  [enter]

박스에 hello fp라는 스트링을 넣었습니다. [enter]

여기에 map을 이용해서 startCase를 해주면 첫 글자만 대문자로 변경된 스트링을 박스에 넣어서 반환해 줍니다.

자, 이렇게 만들어보니 박스에 값을 넣고 map 메소드를 이용하면 박스를 유지한 채로 값을 변경할 수 있게 됐습니다.

게다가 반환 값이 박스 인스턴스이므로 반환 값에 다시 map을 이용해서 값을 변경할 수 있습니다.

사실은 값을 변경했다기 보다 map 메소드를 이용해서 새로운 박스 인스턴스를 반환했다고 말하는게 더 정확합니다.

이전 인스턴스의 값에 변경을 가하지 않고 새로운 Box 인스턴스를 만들었으니까요. [enter]

</Notes>

---

# Functor

> 같은 타입을 반환하는 map 메소드를 구현한 객체

<Notes>

드디어! 이번 주제인 펑터를 만나게 됐습니다.

펑터는 같은 타입을 반환하는 map 메소드를 구현한 객체다 라고 말할 수 있습니다.

방금전과 같이 Box에 다가 map을 사용하게 되면 다시 Box 인스턴스가 반환됐죠.

그래서 박스는 펑터라고 부를수 있게 되는 겁니다.

</Notes>

---

<CodeSurfer>

```js 32:39 file=./src/Functor/box-13.js subtitle="map 사용해서 다시 구현"
```

```js file=./src/Functor/box-14.js
```

```js file=./src/Functor/box-15.js
```

```js file=./src/Functor/box-16.js
```

```js file=./src/Functor/box-17.js
```

```js file=./src/Functor/box-18.js subtitle="상자를 유지한채로 목적 달성"
```

</CodeSurfer>

<Notes>

자 그럼 펑터가 된 박스의 기능을 사용해서 다시한번 구현해 볼까요? [enter]

우선 우리가 파이프라이닝을 사요하고 있기 때문에 펑터의 map을 실행해줄 헬퍼 함수를 하나 만들어 줍니다. 첫번째 인자로 함수를 받구요.

두 번째 인자로 펑터를 받아서 펑터의 map에 함수를 넘겨서 실행해주도록 합니다.[enter]

그럼 처음 박스에 책 목록을 넣은데부터 다시 시작해 보겠습니다. [enter]

박스 형태를 유지하기 위해서 map 함수를 사용합니다. map 함수에 findBookById를 사용하면 박스 안에 책을 넣은 형태로 반환이 됩니다. [enter]

그리고 책의 제목을 가져오기 위해서 다시 한번 map과 prop 함수를 조합해 줍니다. 그러면 박스 안에는 책 제목이 들어있겠죠? [enter]

이제 마지막으로 첫 글자를 대문자로 만들기 위해서 map과 startCase를 조합해 줍니다.

이렇게 하면 상자안의 값을 유지한 상태로 원하는 목적을 달성 했습니다.

</Notes>

---

# 펑터를 왜 사용할까?

굳이 펑터에 값을 넣어서 사용하는 목적이 뭘까?

<Notes>

그런데 굳이 이런 펑터같은 객체를 사용하지 않아도 원하는 요구사항을 구현할 수 있는데 왜 굳이 이런 펑터를 사용할까요?

</Notes>

---

<CodeSurfer>

```js file=./src/Maybe/problem-1.1.js subtitle="책이 두 권"
```

```js file=./src/Maybe/problem-1.2.js subtitle="없는 책은 에러"
```

```js file=./src/Maybe/problem-1.3.js subtitle="findBookById가 undefined 반환"
```

```js 7:8 file=./src/Maybe/problem-1.4.js subtitle="undefined에서 title을 참조"
```

```js file=./src/Maybe/problem-1.5.js
```

```js 6:9 file=./src/Maybe/problem-1.5.js subtitle="prop 함수에서 에러가 났으니 prop 함수를 고쳐주자"
```

```js file=./src/Maybe/lazy-solution-1.js subtitle="obj 먼저 확인"
```

```js file=./src/Maybe/lazy-solution-2.js subtitle="그래도 에러"
```

</CodeSurfer>

<Notes>
함수 합성을 이용해서 함수형 프로그래밍을 할 때 문제가 하나 있습니다.
바로 예외처리가 힘들다는 점인데요. 상황을 한번 살펴보겠습니다.

위 예제에서 books에는 book1과 book2가 있습니다. 그런데 book3를 찾으려고 하면 어떻게 될까요? [enter]
안타 깝게도 이런 에러가 발생합니다. 왜일까요?[enter]

findByBooId에서 book3 라는 아이디로 책을 찾을때 결과로 undefined를 반환합니다. 왜냐면 book3에 해당하는 책이 없으니까요. [enter]

이 반환된 undefined가 prop('title')의 파라미터로 넘어가기 때문에 undefined에서 title 찾도록 실행하게 되죠. [enter]

여기서 에러가 발생하게 됩니다. 그럼 prop 함수에서 에러가 발생했으니 prop에러 예외처리를 해주면 될것 같습니다. [enter]

넘겨받은 obj가 존재하는지 먼저 체크를 해주면 간단히 해결될것 같습니다. 그럼 문제가 해결 될까요? [Enter]

그래도 새로운 에러가 발생합니다. prop 함수는 무사히 지나 갔지만 그 다음 함수인 startCase에서 에러 다시 에러가 발생합니다.

뭔가 본질적인 문제 해결이 필요합니다. 

아니 간단하게 startCase에서도 에러 처리를 해주면 되지 그게 뭐가 문제냐 하시는 분도 계시겠지만. 함수 합성이 계속 해서 10개 20개 이어진다면 어떨까요? 이후에 나오는 모든 함수에서도 예외처리를 넣어줘야 합니다. 말도 안되는 상황이죠.

</Notes>

---

# Maybe

우아한 에러 처리

<Notes>

그래서 이 문제를 해결할 우아한 방법 펑터를 이용한 방법입니다. Maybe도 펑터의 한 종류인데 특별한 기능을 갖는 펑터입니다.

</Notes>

---

<CodeSurferColumns themes={[ imperativeTheme, fpTheme]}>

<Step subtitle="Maybe의 상태는 두 가지 값을 갖는다">

```markdown
Nothing
```

```markdown
Just
```

</Step>

</CodeSurferColumns>


---

<CodeSurferColumns>

<Step>

```js subtitle="값이 null or undefined"
Maybe.of(null) // Nothing
```

```js subtitle="값이 null or undefined 이 아닌 값"
Maybe.of('Hello, FP') // Just('Hello, FP')
```

</Step>

</CodeSurferColumns>

<Notes>

Maybe는 내부적으로 상태값을 갖습니다. Nothing이나 Just 두가지 상태가 가능힙니다. [enter]

두 가지는 박스 안에 들어있는 값에 따라 결정이 되는데요. 박스 안의 값이 undefined이거나 null인 경우 Nothing 상태가 되고. 그 외에는 Just 상태가 됩니다.

Maybe.of에 null을 넣어줬기 대문에 Nothing 상태를 갖게 되구요. 오른쪽은 string 값을 넣엇기 때문에 Just안에 값을 가진 상태가 됩니다.

</Notes>

---

<CodeSurfer>

```js file=./src/Maybe/maybe-1.1.js subtitle="Box 펑터"
```

```js file=./src/Maybe/maybe-1.2.js
```

```js file=./src/Maybe/maybe-1.3.js subtitle="Maybe 상태"
```

```js file=./src/Maybe/maybe-1.4.js subtitle="상태에 따른 map 동작"
```

```js 30 file=./src/Maybe/maybe-1.5.js
```

</CodeSurfer>

<Notes>

자 그럼 박스 펑터를 Maybe 펑터로 바꿔보도록 하겠습니다. [enter] 먼저 이름을 Myabe로 다 바꿔줍니다. [enter]

그리고 maybe 펑터의 상태를 알려주는 isNothing을 구현해 줍니다. 박스 안의 값이 null 이거나 undefined면 Nothing이 되겠죠. [enter]

그리고 이 상태에 따라 map의 구현이 살짝 달라집니다. 

Nothing 상태일 경우는 파라미터 받은 fn을 사용하지 않고 자기 자신을 그대로 반환해 줍니다.
그리고 Nothing이 아닌 Just 상태인 경우는 기존 박스와 마찬가지로 함수를 실행해서 다시 Maybe에 감싸서 반환해 줍니다. [enter]

자 그럼 이전에 구현했던 부분중에 Box를 Maybe로 바꿔보겠습니다.[enter] [enter]

</Notes>


---

<CodeSurfer>

```js 30 file=./src/Maybe/maybe-1.5.js
```

```js 30 file=./src/Maybe/maybe-1.6.js
```

```js file=./src/Maybe/maybe-1.7.js
```

```js 15 file=./src/Maybe/maybe-1.7.js subtitle="Nothing은 map을 건너뛴다"
```

```js file=./src/Maybe/maybe-1.8.js subtitle="에러 없이 프로그램 정상 종료"
```

</CodeSurfer>

<Notes>

그럼 책목록이 null이나 undefined가 아니기 때문에 Just 상태가 되겠죠. [enter]

다음으로 문제가 되던 부분인 findBookById를 하게 되면 책을 못찾아서 undefined가 되기 때문에 Nothing 상태가 됩니다.
그럼 Nothing이 되는 순간부터 map의 구현이 다르다고 했었죠? 다시 한번 살펴보면 [enter]

Nothing 상태인 경우는 map에 넘겨준 함수를 무시하기 때문에 map을 건너뛴다고 생각하면 됩니다. [enter]

</Notes>

---

# Railway Oriented Programming

<Image src={roo} style={{backgroundSize: 'auto'}}/>

<Notes>

이런 프로그래밍 방식을 레일웨이 오리엔티드 프로그래밍 방식이라고 부르기도 한다고 합니다.

Just 상태일때는 파란색 부분으로 흘러가고,

Nothing 상태일때는 원래 로직을 타지 않고 모두 무시하기 때문에 이런 이름이 붙여진것 같습니다.

</Notes>

---

<CodeSurfer>

```js file=./src/Maybe/get-or-else-1.js
```

```js 15,16 file=./src/Maybe/get-or-else-1.js subtitle="결과 값은 Maybe 펑터"
```

```js file=./src/Maybe/get-or-else-2.js
```

```js 7[10:39] file=./src/Maybe/get-or-else-2.js subtitle="Nothing이면 기본 값"
```

```js 7[43:54] file=./src/Maybe/get-or-else-2.js subtitle="Just면 값 반환"
```

```js file=./src/Maybe/get-or-else-3.js
```

```js file=./src/Maybe/get-or-else-4.js
```

```js file=./src/Maybe/get-or-else-5.js
```

</CodeSurfer>

<Notes>

마지막으로 한가지가 더 있는데요. 지금 우리가 최종적으로 갖게 된 값은 스트링이 아니라 Maybe 인스턴스 입니다. [enter]

최종적으로는 우리가 원하는 값인 책 제목을 꺼내야 합니다. 그러기 위해서 펑터 안에 잇는 값을 꺼내줄 헬퍼 함수를 하나 만들어 줍니다. [enter]

이 getOrElse라는 함수는 maybe의 상태가 Nothing인 경우는 첫번째 파라미터로 받은 defaultValue를 반환 합니다. [enter]

반대로 Just인 경우는 Maybe 안에 있는 값을 반환해 줍니다. [enter]

그래서 pipe의 마지막에 getOrElse를 사용해서 값을 꺼내주도록 합니다. [enter]

자 이렇게 하면 Just일때는 우리가 원하는 책 제목을 반환 받게 되구요. [enter]

이렇게 Nothing 일 때는 디폴트 값으로 넘겨준 스트링을 반환 받습니다.

이렇게 펑터를 사용하면 함수 합성시에 발생할 수 있는 에러로 인해 비정상적으로 프로그램이 종료되는것을 막고 우하한 방식으로 에러를 핸들링 할 수 있습니다.

</Notes>

---

<CodeSurfer>

```jsx 5:22 file=./src/CodeStyle/fp-com.js title="함수형 프로그래밍 스타일"
```

</CodeSurfer>

<Notes>

이제 제가 준비한 부분들은 모두 끝났는데요 다시 한번 정리하면

처음에 함수형 프로그래밍 스타일을 먼저 살펴 봤구요. [enter]

</Notes>


---

<CodeSurferColumns>

<Step title="메소드 체이닝 vs 파이프라이닝">

```jsx file=./src/CodeStyle/chaining-com.js subtitle="단단한 결합"
```

```jsx file=./src/CodeStyle/pipelining-com.js subtitle="느슨한 결합"
```

</Step>

</CodeSurferColumns>

<Notes>

메소드 체이닝과 파이프라이닝의 차이점,

</Notes>

---

<CodeSurfer>

```js file=./src/Currying/with-curry-func.js title="Currying, Pointfree Style"
```

</CodeSurfer>

<Notes>

그리고 커링을 통해서 pointfree 스타일로 불필요한 파라미터를 없애는 작업

</Notes>

---

<CodeSurfer>

```js file=./src/Maybe/get-or-else-5.js title="Maybe Functor"
```

</CodeSurfer>

<Notes>

마지막으로 Maybe 펑터를 가지고 함수 조합시 에러처리를 하는 방법까지 같이 살펴봤습니다.

개인적으로 함수형 프로그래밍을 하면서 가독성 향상에 큰 변화를 느꼈구요.
그러다보니 코드 유지보수에도 많은 도움도 되고,
또 순수함수를 기반으로 작업을 하려고 노력하다보니 예상치못한 곳에서 값을 변경해서 생기는 버그도 많이 줄일 수 있었습니다.

여러분도 오늘 제 발표를 듣고 함수형 프로그래밍에 관심이 생겼다 하시면 도전해보시고 저와 같은 좋은 경험을 하셨으면 좋겠습니다.

오늘 제 발표는 여기까지구요. [enter]

</Notes>

---

# Q & A

More 👉 https://velog.io/@nakta/series/FP-in-JS

<Notes>

혹시나 오늘 발표한것 외에 더 알고 싶다 하시는 분들은 홍보는 아니지만 에전에 제가 정리했던 블로그 글이 있습니다.

한번 방문하셔서 참고하시면 도움이 되시지 않을까 합니다.

긴 발표 들어주시느라 고생하셨습니다. 혹시 궁금한점 있으신분 계실까요?

</Notes>

---

# 고맙습니다 😃
